"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNetlifyNextServer = void 0;
const handlerUtils_1 = require("./handlerUtils");
const getNetlifyNextServer = (NextServer) => {
    class NetlifyNextServer extends NextServer {
        constructor(options, netlifyConfig) {
            super(options);
            this.netlifyConfig = netlifyConfig;
            // copy the prerender manifest so it doesn't get mutated by Next.js
            const manifest = this.getPrerenderManifest();
            this.netlifyPrerenderManifest = {
                ...manifest,
                routes: { ...manifest.routes },
                dynamicRoutes: { ...manifest.dynamicRoutes },
            };
        }
        getRequestHandler() {
            const handler = super.getRequestHandler();
            return async (req, res, parsedUrl) => {
                // preserve the URL before Next.js mutates it for i18n
                const { url, headers } = req;
                if (headers['x-prerender-revalidate'] && this.netlifyConfig.revalidateToken) {
                    // handle on-demand revalidation by purging the ODB cache
                    await this.netlifyRevalidate(url);
                    res = res;
                    res.statusCode = 200;
                    res.setHeader('x-nextjs-cache', 'REVALIDATED');
                    res.send();
                }
                else {
                    return handler(req, res, parsedUrl);
                }
            };
        }
        async netlifyRevalidate(route) {
            try {
                // call netlify API to revalidate the path
                const result = await (0, handlerUtils_1.netlifyApiFetch)({
                    endpoint: `sites/${process.env.SITE_ID}/refresh_on_demand_builders`,
                    payload: {
                        paths: this.getNetlifyPathsForRoute(route),
                        domain: this.hostname,
                    },
                    token: this.netlifyConfig.revalidateToken,
                    method: 'POST',
                });
                if (!result.ok) {
                    throw new Error(result.message);
                }
            }
            catch (error) {
                console.log(`Error revalidating ${route}:`, error.message);
                throw error;
            }
        }
        getNetlifyPathsForRoute(route) {
            const { i18n } = this.nextConfig;
            const { routes, dynamicRoutes } = this.netlifyPrerenderManifest;
            // matches static routes
            const normalizedRoute = (0, handlerUtils_1.normalizeRoute)(i18n ? (0, handlerUtils_1.localizeRoute)(route, i18n) : route);
            if (normalizedRoute in routes) {
                const { dataRoute } = routes[normalizedRoute];
                const normalizedDataRoute = i18n ? (0, handlerUtils_1.localizeDataRoute)(dataRoute, normalizedRoute) : dataRoute;
                return [route, normalizedDataRoute];
            }
            // matches dynamic routes
            const unlocalizedRoute = i18n ? (0, handlerUtils_1.unlocalizeRoute)(normalizedRoute, i18n) : normalizedRoute;
            for (const dynamicRoute in dynamicRoutes) {
                const { dataRoute, routeRegex } = dynamicRoutes[dynamicRoute];
                const matches = unlocalizedRoute.match(routeRegex);
                if ((matches === null || matches === void 0 ? void 0 : matches.length) > 0) {
                    // remove the first match, which is the full route
                    matches.shift();
                    // replace the dynamic segments with the actual values
                    const interpolatedDataRoute = dataRoute.replace(/\[(.*?)]/g, () => matches.shift());
                    const normalizedDataRoute = i18n
                        ? (0, handlerUtils_1.localizeDataRoute)(interpolatedDataRoute, normalizedRoute)
                        : interpolatedDataRoute;
                    return [route, normalizedDataRoute];
                }
            }
            throw new Error(`not an ISR route`);
        }
    }
    return NetlifyNextServer;
};
exports.getNetlifyNextServer = getNetlifyNextServer;
